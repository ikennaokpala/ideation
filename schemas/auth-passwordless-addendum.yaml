# SPARC v6.1 AUTHENTICATION ADDENDUM
# Passwordless Authentication: OTP + Social Login Only
#
# CRITICAL: This supersedes any password-based authentication in the base schemas.
# All authentication MUST be passwordless via:
# 1. OTP (Email or SMS/Phone)
# 2. Social Login (OAuth providers)
#
# NO PASSWORDS. EVER.

$schema: "https://sparc-dsl.dev/schemas/auth-passwordless.yaml.json"
version: "1.0"

# ═══════════════════════════════════════════════════════════════════════════════
# AUTHENTICATION PHILOSOPHY
# ═══════════════════════════════════════════════════════════════════════════════

philosophy:
  
  principle: "Passwordless-first, always"
  
  rationale:
    - "Passwords are the #1 security vulnerability"
    - "Users reuse passwords across services"
    - "Password management is friction"
    - "OTP and Social Login are more secure and convenient"
    - "Modern users expect passwordless options"
    
  allowed_methods:
    - "OTP via Email"
    - "OTP via SMS/Phone"
    - "Social Login (OAuth 2.0)"
    
  forbidden_methods:
    - "Password + Email"
    - "Password + Username"
    - "Security questions"
    - "Any password-based authentication"

# ═══════════════════════════════════════════════════════════════════════════════
# IDENTITY MODEL (Passwordless)
# ═══════════════════════════════════════════════════════════════════════════════

identity_model:
  
  user:
    description: "A person using the platform - NO password field"
    
    fields:
      - name: "id"
        type: "uuid"
        description: "Unique identifier (ULID or UUIDv7 recommended)"
        
      - name: "email"
        type: "string"
        unique: true
        nullable: false
        description: "Primary email - used for OTP delivery"
        
      - name: "email_verified"
        type: "boolean"
        default: false
        description: "Email verification status"
        
      - name: "phone"
        type: "string"
        unique: true
        nullable: true
        description: "Phone number for SMS OTP (E.164 format)"
        
      - name: "phone_verified"
        type: "boolean"
        default: false
        description: "Phone verification status"
        
      - name: "name"
        type: "string"
        nullable: true
        description: "Display name (often from OAuth provider)"
        
      - name: "avatar_url"
        type: "string"
        nullable: true
        description: "Profile picture URL"
        
      - name: "preferred_auth_method"
        type: "enum"
        values: ["email_otp", "sms_otp", "social"]
        default: "email_otp"
        description: "User's preferred authentication method"
        
      - name: "last_login_at"
        type: "timestamp"
        nullable: true
        
      - name: "created_at"
        type: "timestamp"
        
      - name: "updated_at"
        type: "timestamp"
        
    # NOTE: NO password_hash field!
    
  oauth_connection:
    description: "Link between user and OAuth provider"
    
    fields:
      - name: "id"
        type: "uuid"
        
      - name: "user_id"
        type: "uuid"
        references: "user.id"
        
      - name: "provider"
        type: "enum"
        values: ["google", "apple", "github", "microsoft", "facebook", "linkedin"]
        
      - name: "provider_user_id"
        type: "string"
        description: "User ID from the OAuth provider"
        
      - name: "email"
        type: "string"
        description: "Email from OAuth provider"
        
      - name: "access_token"
        type: "string"
        encrypted: true
        nullable: true
        description: "Encrypted access token (if needed for API access)"
        
      - name: "refresh_token"
        type: "string"
        encrypted: true
        nullable: true
        
      - name: "token_expires_at"
        type: "timestamp"
        nullable: true
        
      - name: "raw_profile"
        type: "jsonb"
        description: "Raw profile data from provider"
        
      - name: "created_at"
        type: "timestamp"
        
    indexes:
      - columns: ["provider", "provider_user_id"]
        unique: true
      - columns: ["user_id", "provider"]
        unique: true
        
  otp_request:
    description: "OTP request tracking"
    
    fields:
      - name: "id"
        type: "uuid"
        
      - name: "identifier"
        type: "string"
        description: "Email or phone number"
        
      - name: "identifier_type"
        type: "enum"
        values: ["email", "phone"]
        
      - name: "code_hash"
        type: "string"
        description: "Hashed OTP code"
        
      - name: "purpose"
        type: "enum"
        values: ["login", "signup", "verify_email", "verify_phone", "link_account"]
        
      - name: "attempts"
        type: "integer"
        default: 0
        description: "Failed verification attempts"
        
      - name: "max_attempts"
        type: "integer"
        default: 3
        
      - name: "expires_at"
        type: "timestamp"
        
      - name: "verified_at"
        type: "timestamp"
        nullable: true
        
      - name: "created_at"
        type: "timestamp"
        
    indexes:
      - columns: ["identifier", "purpose"]
        where: "verified_at IS NULL AND expires_at > NOW()"
        
    ttl:
      column: "expires_at"
      cleanup: "automatic"

# ═══════════════════════════════════════════════════════════════════════════════
# OTP AUTHENTICATION
# ═══════════════════════════════════════════════════════════════════════════════

otp_authentication:
  
  description: |
    One-Time Password authentication via email or SMS.
    User enters their email/phone, receives a code, enters the code to authenticate.
    
  channels:
    
    email:
      enabled: true
      
      code:
        length: 6
        type: "numeric"           # numeric | alphanumeric
        ttl: "10m"                # Time to live
        
      rate_limits:
        per_email:
          requests: 5
          window: "15m"
        per_ip:
          requests: 10
          window: "15m"
          
      delivery:
        provider: "sendgrid"      # sendgrid | postmark | ses | resend
        from_email: "auth@{{domain}}"
        from_name: "{{app_name}}"
        
        template:
          subject: "Your {{app_name}} login code"
          body: |
            Your verification code is: {{code}}
            
            This code expires in 10 minutes.
            
            If you didn't request this code, you can safely ignore this email.
            
    sms:
      enabled: true
      
      code:
        length: 6
        type: "numeric"
        ttl: "5m"                 # Shorter TTL for SMS
        
      rate_limits:
        per_phone:
          requests: 3
          window: "15m"
        per_ip:
          requests: 5
          window: "15m"
          
      delivery:
        provider: "twilio"        # twilio | messagebird | vonage
        from_number: "{{twilio_number}}"
        
        template:
          body: "Your {{app_name}} code is {{code}}. Expires in 5 min."
          
  security:
    
    code_hashing: true            # Store hashed codes, not plaintext
    hash_algorithm: "argon2id"
    
    max_attempts: 3               # Lock after 3 failed attempts
    lockout_duration: "15m"
    
    prevent_enumeration: true     # Same response whether email exists or not
    
    ip_tracking: true             # Track IP for suspicious activity
    device_fingerprinting: false  # Optional

# ═══════════════════════════════════════════════════════════════════════════════
# SOCIAL LOGIN (OAuth 2.0)
# ═══════════════════════════════════════════════════════════════════════════════

social_login:
  
  description: |
    OAuth 2.0 based social login. User clicks provider button,
    authenticates with provider, and is redirected back with identity.
    
  providers:
    
    - name: "google"
      enabled: true
      display_name: "Google"
      icon: "google"
      
      config:
        authorization_url: "https://accounts.google.com/o/oauth2/v2/auth"
        token_url: "https://oauth2.googleapis.com/token"
        userinfo_url: "https://www.googleapis.com/oauth2/v2/userinfo"
        
        scopes:
          - "openid"
          - "email"
          - "profile"
          
        claims_mapping:
          id: "id"
          email: "email"
          name: "name"
          avatar: "picture"
          email_verified: "verified_email"
          
    - name: "apple"
      enabled: true
      display_name: "Apple"
      icon: "apple"
      
      config:
        authorization_url: "https://appleid.apple.com/auth/authorize"
        token_url: "https://appleid.apple.com/auth/token"
        
        scopes:
          - "name"
          - "email"
          
        # Apple returns user info in ID token, not userinfo endpoint
        id_token_claims: true
        
        claims_mapping:
          id: "sub"
          email: "email"
          name: "name"            # Only on first auth
          
    - name: "github"
      enabled: true
      display_name: "GitHub"
      icon: "github"
      
      config:
        authorization_url: "https://github.com/login/oauth/authorize"
        token_url: "https://github.com/login/oauth/access_token"
        userinfo_url: "https://api.github.com/user"
        emails_url: "https://api.github.com/user/emails"
        
        scopes:
          - "read:user"
          - "user:email"
          
        claims_mapping:
          id: "id"
          email: "email"          # From emails endpoint
          name: "name"
          avatar: "avatar_url"
          
    - name: "microsoft"
      enabled: true
      display_name: "Microsoft"
      icon: "microsoft"
      
      config:
        authorization_url: "https://login.microsoftonline.com/common/oauth2/v2.0/authorize"
        token_url: "https://login.microsoftonline.com/common/oauth2/v2.0/token"
        userinfo_url: "https://graph.microsoft.com/v1.0/me"
        
        scopes:
          - "openid"
          - "email"
          - "profile"
          
        claims_mapping:
          id: "id"
          email: "mail"
          name: "displayName"
          
    - name: "facebook"
      enabled: false              # Enable if needed
      display_name: "Facebook"
      icon: "facebook"
      
    - name: "linkedin"
      enabled: false              # Enable if needed
      display_name: "LinkedIn"
      icon: "linkedin"
      
  security:
    
    state_parameter: true         # CSRF protection
    state_ttl: "10m"
    
    pkce: true                    # Proof Key for Code Exchange
    pkce_method: "S256"
    
    nonce: true                   # For ID token validation
    
    allowed_redirect_origins:
      - "{{app_url}}"
      - "{{app_url}}/auth/callback"

# ═══════════════════════════════════════════════════════════════════════════════
# AUTHENTICATION FLOWS
# ═══════════════════════════════════════════════════════════════════════════════

flows:
  
  # ─────────────────────────────────────────────────────────────────────────────
  # SIGNUP FLOW (New User)
  # ─────────────────────────────────────────────────────────────────────────────
  
  signup:
    
    via_email_otp:
      steps:
        - step: 1
          action: "User enters email"
          endpoint: "POST /auth/otp/request"
          request:
            email: "string (required)"
            purpose: "signup"
          response:
            message: "Code sent"
            expires_in: 600
          notes: "Same response whether email exists or not (enumeration protection)"
          
        - step: 2
          action: "System sends OTP to email"
          internal: true
          
        - step: 3
          action: "User enters OTP code"
          endpoint: "POST /auth/otp/verify"
          request:
            email: "string"
            code: "string (6 digits)"
            purpose: "signup"
          response:
            access_token: "jwt"
            refresh_token: "string"
            user:
              id: "uuid"
              email: "string"
              email_verified: true
          notes: "Creates user if doesn't exist, logs in if exists"
          
    via_social:
      steps:
        - step: 1
          action: "User clicks social login button"
          endpoint: "GET /auth/oauth/{provider}"
          response: "Redirect to provider"
          
        - step: 2
          action: "User authenticates with provider"
          external: true
          
        - step: 3
          action: "Provider redirects back with code"
          endpoint: "GET /auth/oauth/{provider}/callback"
          query_params:
            code: "string"
            state: "string"
          response:
            access_token: "jwt"
            refresh_token: "string"
            user:
              id: "uuid"
              email: "string"
              name: "string"
              avatar_url: "string"
          notes: "Creates user if doesn't exist, links account if exists"
          
  # ─────────────────────────────────────────────────────────────────────────────
  # LOGIN FLOW (Existing User)
  # ─────────────────────────────────────────────────────────────────────────────
  
  login:
    
    via_email_otp:
      description: "Identical to signup - same endpoint, creates or logs in"
      steps:
        - step: 1
          action: "User enters email"
          endpoint: "POST /auth/otp/request"
          request:
            email: "string"
            purpose: "login"
            
        - step: 2
          action: "System sends OTP"
          internal: true
          
        - step: 3
          action: "User enters OTP"
          endpoint: "POST /auth/otp/verify"
          notes: "Same flow as signup - seamless"
          
    via_sms_otp:
      steps:
        - step: 1
          action: "User enters phone number"
          endpoint: "POST /auth/otp/request"
          request:
            phone: "string (E.164 format)"
            purpose: "login"
            
        - step: 2
          action: "System sends SMS"
          internal: true
          
        - step: 3
          action: "User enters OTP"
          endpoint: "POST /auth/otp/verify"
          request:
            phone: "string"
            code: "string"
            purpose: "login"
            
    via_social:
      description: "Same as signup social flow"
      
  # ─────────────────────────────────────────────────────────────────────────────
  # ACCOUNT LINKING
  # ─────────────────────────────────────────────────────────────────────────────
  
  link_account:
    
    description: "Link additional auth methods to existing account"
    requires_auth: true
    
    link_social:
      steps:
        - step: 1
          action: "User initiates linking"
          endpoint: "GET /auth/oauth/{provider}/link"
          headers:
            Authorization: "Bearer {access_token}"
            
        - step: 2
          action: "OAuth flow"
          external: true
          
        - step: 3
          action: "Provider callback"
          endpoint: "GET /auth/oauth/{provider}/callback"
          notes: "Links to authenticated user instead of creating new"
          
    link_phone:
      steps:
        - step: 1
          action: "User requests phone verification"
          endpoint: "POST /auth/otp/request"
          headers:
            Authorization: "Bearer {access_token}"
          request:
            phone: "string"
            purpose: "verify_phone"
            
        - step: 2
          action: "User verifies OTP"
          endpoint: "POST /auth/otp/verify"
          request:
            phone: "string"
            code: "string"
            purpose: "verify_phone"
          response:
            phone_verified: true

# ═══════════════════════════════════════════════════════════════════════════════
# API ENDPOINTS
# ═══════════════════════════════════════════════════════════════════════════════

api:
  
  base_path: "/api/v1/auth"
  
  endpoints:
    
    # OTP Endpoints
    - path: "/otp/request"
      method: "POST"
      description: "Request OTP code via email or SMS"
      auth: false
      
      request_body:
        email:
          type: "string"
          format: "email"
          required: false
        phone:
          type: "string"
          pattern: "^\\+[1-9]\\d{1,14}$"
          required: false
        purpose:
          type: "string"
          enum: ["login", "signup", "verify_email", "verify_phone"]
          default: "login"
          
      responses:
        200:
          description: "OTP sent (same response whether identifier exists or not)"
          body:
            message: "string"
            expires_in: "integer (seconds)"
        400:
          description: "Invalid request"
          body:
            error: "INVALID_EMAIL | INVALID_PHONE | MISSING_IDENTIFIER"
        429:
          description: "Rate limited"
          body:
            error: "RATE_LIMITED"
            retry_after: "integer (seconds)"
            
    - path: "/otp/verify"
      method: "POST"
      description: "Verify OTP and authenticate"
      auth: false
      
      request_body:
        email:
          type: "string"
          required: false
        phone:
          type: "string"
          required: false
        code:
          type: "string"
          pattern: "^[0-9]{6}$"
          required: true
        purpose:
          type: "string"
          enum: ["login", "signup", "verify_email", "verify_phone"]
          required: true
          
      responses:
        200:
          description: "Authentication successful"
          body:
            access_token: "string (JWT)"
            refresh_token: "string"
            expires_in: "integer (seconds)"
            token_type: "Bearer"
            user:
              id: "string (uuid)"
              email: "string"
              phone: "string | null"
              name: "string | null"
              avatar_url: "string | null"
              email_verified: "boolean"
              phone_verified: "boolean"
        400:
          description: "Invalid or expired code"
          body:
            error: "INVALID_CODE | EXPIRED_CODE | MAX_ATTEMPTS_EXCEEDED"
        429:
          description: "Too many attempts"
          body:
            error: "LOCKED_OUT"
            retry_after: "integer (seconds)"
            
    # OAuth Endpoints
    - path: "/oauth/{provider}"
      method: "GET"
      description: "Initiate OAuth flow"
      auth: false
      
      path_params:
        provider:
          type: "string"
          enum: ["google", "apple", "github", "microsoft"]
          
      query_params:
        redirect_uri:
          type: "string"
          required: false
          description: "Override default redirect URI"
          
      responses:
        302:
          description: "Redirect to OAuth provider"
        400:
          description: "Invalid provider"
          
    - path: "/oauth/{provider}/callback"
      method: "GET"
      description: "OAuth callback handler"
      auth: false
      
      query_params:
        code:
          type: "string"
          required: true
        state:
          type: "string"
          required: true
        error:
          type: "string"
          required: false
          
      responses:
        302:
          description: "Redirect to app with tokens"
          headers:
            Location: "{{app_url}}/auth/callback?token=..."
        400:
          description: "OAuth error"
          
    # Session Management
    - path: "/refresh"
      method: "POST"
      description: "Refresh access token"
      auth: false
      
      request_body:
        refresh_token:
          type: "string"
          required: true
          
      responses:
        200:
          description: "New tokens issued"
          body:
            access_token: "string"
            refresh_token: "string"
            expires_in: "integer"
        401:
          description: "Invalid refresh token"
          
    - path: "/logout"
      method: "POST"
      description: "Logout and invalidate session"
      auth: true
      
      responses:
        204:
          description: "Logged out successfully"
          
    # User Info
    - path: "/me"
      method: "GET"
      description: "Get current user info"
      auth: true
      
      responses:
        200:
          body:
            id: "string"
            email: "string"
            phone: "string | null"
            name: "string | null"
            avatar_url: "string | null"
            email_verified: "boolean"
            phone_verified: "boolean"
            oauth_connections:
              - provider: "string"
                connected_at: "timestamp"
            preferred_auth_method: "string"
            created_at: "timestamp"

# ═══════════════════════════════════════════════════════════════════════════════
# UNIFIED PLATFORM AUTHENTICATION
# Cross-service authentication for platforms
# ═══════════════════════════════════════════════════════════════════════════════

platform_auth:
  
  description: |
    When building a platform with multiple services/applications,
    authentication is centralized in the auth service. All other
    services validate tokens against this central auth.
    
  architecture:
    
    type: "centralized_auth_service"
    
    auth_service:
      name: "{{platform}}-auth"
      repository: "{{platform}}-auth"
      standalone: true
      
      responsibilities:
        - "User registration (OTP + Social only)"
        - "Authentication (OTP + Social only)"
        - "Token issuance"
        - "Token refresh"
        - "Session management"
        - "OAuth provider integration"
        - "Organization management"
        
    other_services:
      token_validation:
        method: "jwt_public_key"
        description: |
          Each service has the auth service's public key and validates
          JWTs locally. No network call needed for validation.
          
      user_context:
        method: "jwt_claims"
        description: |
          User ID, org ID, role, and permissions are in JWT claims.
          Services extract context from token without calling auth service.
          
      service_to_service:
        method: "internal_api_key"
        description: |
          For cases where a service needs to call auth service directly
          (e.g., to look up user details), use internal API keys.
          
  token_strategy:
    
    type: "jwt"
    algorithm: "RS256"
    
    key_management:
      private_key: "Stored only in auth service"
      public_key: "Distributed to all services"
      rotation: "Monthly, with overlap period"
      
    access_token:
      ttl: "15m"
      claims:
        sub: "User ID"
        email: "User email"
        org_id: "Current organization"
        role: "Role in organization"
        permissions: "Array of permissions"
        auth_method: "otp_email | otp_sms | oauth_{provider}"
        
    refresh_token:
      ttl: "7d"
      rotation: true
      storage: "Database (auth service only)"
      
  cross_service_flows:
    
    user_accesses_product:
      steps:
        - "User has access token from auth service"
        - "User makes request to product service"
        - "Product service validates JWT with public key"
        - "Product service extracts user context from claims"
        - "Product service authorizes based on permissions"
        - "Product service processes request"
        
    product_needs_user_details:
      steps:
        - "Product service has user ID from JWT"
        - "Product service calls auth service internal API"
        - "Auth service returns user details"
        
  repository_structure:
    
    description: |
      Each bounded context/application is a separate Git repository.
      Auth is the shared service that all others depend on.
      
    repositories:
      - name: "{{platform}}-auth"
        type: "shared_service"
        contains:
          - "OTP authentication"
          - "OAuth integration"
          - "Token management"
          - "User management"
          - "Organization management"
          
      - name: "{{platform}}-{product}"
        type: "product"
        depends_on:
          - "{{platform}}-auth"
        auth_integration:
          - "JWT validation middleware"
          - "Public key configuration"
          - "Permission checking"

# ═══════════════════════════════════════════════════════════════════════════════
# MIGRATION NOTES (If converting from password-based)
# ═══════════════════════════════════════════════════════════════════════════════

migration:
  
  from_password_auth:
    
    description: |
      If you have existing password-based authentication, here's how to migrate
      to passwordless OTP + Social.
      
    strategy:
      
      - phase: 1
        name: "Add OTP alongside passwords"
        actions:
          - "Add OTP endpoints"
          - "Add Social Login"
          - "Keep password login working"
          - "Encourage users to add email/phone for OTP"
          
      - phase: 2
        name: "Promote passwordless"
        actions:
          - "Default to OTP on login page"
          - "Show password as secondary option"
          - "Send emails encouraging social login linking"
          
      - phase: 3
        name: "Deprecate passwords"
        actions:
          - "Hide password login behind 'legacy' link"
          - "Require OTP or Social for new accounts"
          - "Send migration deadline notices"
          
      - phase: 4
        name: "Remove passwords"
        actions:
          - "Remove password login entirely"
          - "Force remaining users to set up OTP"
          - "Drop password_hash column (after backup)"
          
    data_migration:
      - "Keep email (for OTP)"
      - "Drop password_hash column"
      - "Add phone column"
      - "Add preferred_auth_method column"
      - "Create oauth_connections table"
      - "Create otp_requests table"

# ═══════════════════════════════════════════════════════════════════════════════
# WHITE-LABEL AUTH CUSTOMIZATION
# ═══════════════════════════════════════════════════════════════════════════════

white_label:
  
  description: |
    When deploying auth for white-label clients, these elements can be customized
    per tenant.
    
  customizable:
    
    branding:
      - "Login page logo"
      - "Login page background"
      - "Primary color"
      - "Email template branding"
      - "SMS sender name (where supported)"
      
    providers:
      - "Enable/disable specific OAuth providers"
      - "Custom OAuth app credentials per tenant"
      - "Custom email provider per tenant"
      - "Custom SMS provider per tenant"
      
    configuration:
      - "OTP code length (6-8 digits)"
      - "OTP TTL"
      - "Session duration"
      - "Rate limits"
      
    domain:
      - "Custom auth domain (auth.client.com)"
      - "Custom callback URLs"
      - "Custom email from address"
      
  tenant_isolation:
    
    user_data: "Schema per tenant"
    oauth_connections: "Tenant-scoped"
    sessions: "Tenant-scoped in Redis"
