# SIMULATION MODES
# Interactive exploration and validation tools for SPARC specifications
#
# These simulations allow you to:
# - Visualize competitive landscape
# - Explore all cyclomatic paths
# - Preview UI without building
# - Test APIs with mock server
# - Estimate infrastructure costs
# - Validate test coverage

$schema: "https://sparc-dsl.dev/schemas/simulation-modes.schema.json"
version: "1.1"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# IMPLEMENTATION STATUS
# Tracks what's built vs what's spec'd - prioritized by developer value
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

implementation_status:

  description: |
    This section tracks the implementation status of each feature.
    Status: "implemented" | "in_progress" | "planned" | "spec_only"

    PRIORITIZATION RATIONALE:
    Priority 1 - Direct value to developers writing code from specs
    Priority 2 - Validation and quality assurance
    Priority 3 - Visualization and exploration
    Priority 4 - Business/strategy tools

  priority_1_core:
    description: "Essential for developers - implement first"
    features:
      - name: "sparc generate api"
        status: "implemented"
        version: "0.1.0"
        description: "Generate API routes from dsl/api.yaml"

      - name: "sparc sim api:mock"
        status: "implemented"
        version: "0.1.0"
        description: "Mock server from API spec"

      - name: "sparc generate db"
        status: "implemented"
        version: "0.1.0"
        description: "Generate database schema/migrations"

      - name: "sparc sim software:paths"
        status: "implemented"
        version: "0.1.0"
        description: "Interactive cyclomatic path explorer"

      - name: "sparc validate"
        status: "implemented"
        version: "0.1.0"
        description: "Schema validation for all YAML files"

  priority_2_quality:
    description: "Quality assurance - implement second"
    features:
      - name: "sparc generate tests"
        status: "in_progress"
        version: "0.2.0"
        description: "Generate test scaffolding from paths"

      - name: "sparc sim tests:coverage"
        status: "in_progress"
        version: "0.2.0"
        description: "Path-to-test coverage mapping"

      - name: "sparc lint"
        status: "planned"
        version: "0.3.0"
        description: "Best practices linting"

  priority_3_visualization:
    description: "Exploration tools - implement third"
    features:
      - name: "sparc sim data:diagram"
        status: "planned"
        version: "0.3.0"
        description: "ERD visualization"

      - name: "sparc sim software:states"
        status: "planned"
        version: "0.3.0"
        description: "State machine viewer"

      - name: "sparc interactive"
        status: "planned"
        version: "0.4.0"
        description: "Full dashboard"

  priority_4_business:
    description: "Strategy tools - implement last"
    features:
      - name: "sparc sim business:landscape"
        status: "spec_only"
        version: "0.5.0"
        description: "Competitive landscape chart"

      - name: "sparc sim business:pricing"
        status: "spec_only"
        version: "0.5.0"
        description: "Pricing comparison"

      - name: "sparc sim deploy:cost"
        status: "spec_only"
        version: "0.6.0"
        description: "Infrastructure cost estimation"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SPARC CLI SPECIFICATION
# Implementation guide for the sparc command-line tool
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

cli:
  name: "sparc"
  version: "6.1.1"

  installation:
    npm: "npm install -g @sparc-dsl/cli"
    npx: "npx @sparc-dsl/cli <command>"

  commands:
    - name: "init"
      syntax: "sparc init [--template <name>] [--level <0-3>]"
      description: "Initialize new SPARC project structure"
      implemented: true

    - name: "generate"
      syntax: "sparc generate <target> [--output <dir>]"
      description: "Generate code from DSL specifications"
      implemented: true
      targets: ["api", "db", "ui", "tests", "all"]

    - name: "sim"
      syntax: "sparc sim <category>:<mode>"
      description: "Run interactive simulations"
      implemented: true

    - name: "validate"
      syntax: "sparc validate [--fix]"
      description: "Validate all specification files against JSON schemas"
      implemented: true

    - name: "upgrade"
      syntax: "sparc upgrade --to <level>"
      description: "Upgrade project to higher complexity level"
      implemented: true

    - name: "lint"
      syntax: "sparc lint"
      description: "Check specifications for best practices"
      implemented: false

    - name: "interactive"
      syntax: "sparc interactive"
      description: "Launch full interactive dashboard"
      implemented: false

  # Implementation architecture
  implementation:
    language: "TypeScript"
    runtime: "Node.js >= 18"

    package_json: |
      {
        "name": "@sparc-dsl/cli",
        "version": "0.1.0",
        "description": "SPARC specification toolkit",
        "bin": {
          "sparc": "./dist/cli.js"
        },
        "scripts": {
          "build": "tsc",
          "dev": "tsx watch src/cli.ts",
          "test": "vitest"
        },
        "dependencies": {
          "yaml": "^2.3.4",
          "ajv": "^8.12.0",
          "ajv-formats": "^2.1.1",
          "handlebars": "^4.7.8",
          "express": "^4.18.2",
          "cors": "^2.8.5",
          "open": "^9.1.0",
          "chalk": "^5.3.0",
          "ora": "^7.0.1",
          "commander": "^11.1.0",
          "glob": "^10.3.10",
          "chokidar": "^3.5.3"
        },
        "devDependencies": {
          "@types/express": "^4.17.21",
          "@types/cors": "^2.8.17",
          "@types/node": "^20.10.0",
          "typescript": "^5.3.2",
          "tsx": "^4.6.0",
          "vitest": "^1.0.0"
        }
      }

    directory_structure: |
      src/
      â”œâ”€â”€ cli.ts                    # Entry point
      â”œâ”€â”€ commands/
      â”‚   â”œâ”€â”€ init.ts               # sparc init
      â”‚   â”œâ”€â”€ generate.ts           # sparc generate
      â”‚   â”œâ”€â”€ validate.ts           # sparc validate
      â”‚   â”œâ”€â”€ sim.ts                # sparc sim
      â”‚   â””â”€â”€ upgrade.ts            # sparc upgrade
      â”œâ”€â”€ generators/
      â”‚   â”œâ”€â”€ api-generator.ts      # Generate API routes
      â”‚   â”œâ”€â”€ db-generator.ts       # Generate DB schema
      â”‚   â”œâ”€â”€ test-generator.ts     # Generate test files
      â”‚   â””â”€â”€ templates/            # Handlebars templates
      â”œâ”€â”€ simulations/
      â”‚   â”œâ”€â”€ mock-server.ts        # API mock server
      â”‚   â”œâ”€â”€ path-explorer.ts      # Cyclomatic path explorer
      â”‚   â””â”€â”€ coverage.ts           # Test coverage
      â”œâ”€â”€ validation/
      â”‚   â”œâ”€â”€ schema-validator.ts   # JSON Schema validation
      â”‚   â””â”€â”€ cross-ref-validator.ts
      â””â”€â”€ utils/
          â”œâ”€â”€ yaml-loader.ts
          â”œâ”€â”€ file-writer.ts
          â””â”€â”€ logger.ts

    entry_point: |
      #!/usr/bin/env node
      // src/cli.ts
      import { Command } from 'commander';
      import chalk from 'chalk';
      import { initCommand } from './commands/init';
      import { generateCommand } from './commands/generate';
      import { validateCommand } from './commands/validate';
      import { simCommand } from './commands/sim';
      import { upgradeCommand } from './commands/upgrade';

      const program = new Command();

      program
        .name('sparc')
        .version('0.1.0')
        .description('SPARC specification toolkit - transform specs into code');

      // sparc init
      program
        .command('init')
        .description('Initialize new SPARC project')
        .option('-t, --template <name>', 'Project template', 'crud_api')
        .option('-l, --level <number>', 'Complexity level (0-3)', '0')
        .option('--dir <path>', 'Output directory', '.')
        .action(initCommand);

      // sparc generate <target>
      program
        .command('generate <target>')
        .description('Generate code from DSL specifications')
        .option('-o, --output <dir>', 'Output directory')
        .option('--dry-run', 'Show what would be generated')
        .option('--force', 'Overwrite existing files')
        .action(generateCommand);

      // sparc validate
      program
        .command('validate')
        .description('Validate specification files')
        .option('--fix', 'Auto-fix fixable issues')
        .option('--verbose', 'Show detailed validation info')
        .action(validateCommand);

      // sparc sim <mode>
      program
        .command('sim <mode>')
        .description('Run simulation (api:mock, software:paths, tests:coverage)')
        .option('-p, --port <number>', 'Server port', '3000')
        .option('--stateful', 'Enable stateful mode for mock server')
        .option('--delay <ms>', 'Add response delay')
        .option('--error-rate <percent>', 'Simulate error rate')
        .action(simCommand);

      // sparc upgrade
      program
        .command('upgrade')
        .description('Upgrade project complexity level')
        .requiredOption('--to <level>', 'Target level (mvp, competitive, full)')
        .action(upgradeCommand);

      program.parse();

      // Handle unknown commands
      program.on('command:*', () => {
        console.error(chalk.red(`Unknown command: ${program.args.join(' ')}`));
        console.log(`Run ${chalk.cyan('sparc --help')} for usage.`);
        process.exit(1);
      });

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BUSINESS SIMULATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

business:

  - name: "competitive_landscape"
    command: "sparc sim business:landscape"
    description: "Visual competitive positioning map"

    input:
      - "business/competitors/*.yaml"
      - "business/ideal/business-ideal.yaml"

    output:
      type: "interactive_chart"
      format: "html"

    features:
      - "2D positioning map (price vs feature completeness)"
      - "Market share bubbles"
      - "Segment filters"
      - "Your projected position highlighted"
      - "Export to PNG/SVG"

    implementation:
      library: "chart.js"
      server_port: 3001
      code_example: |
        // src/simulations/business/landscape.ts
        import { Chart } from 'chart.js';
        import { loadCompetitors } from '../loaders';

        export async function renderLandscape(specDir: string) {
          const competitors = await loadCompetitors(`${specDir}/business/competitors`);
          const ideal = await loadYaml(`${specDir}/business/ideal/business-ideal.yaml`);

          const data = competitors.map(c => ({
            x: c.pricing.average_monthly_cost,
            y: c.feature_completeness_score,
            r: c.market_share * 100,
            label: c.name
          }));

          // Add projected position
          data.push({
            x: ideal.optimal_business_model.pricing_strategy.target_price,
            y: ideal.competitive_positioning.feature_completeness,
            r: 10,
            label: 'Your Product (Projected)',
            highlighted: true
          });

          return {
            type: 'bubble',
            data: { datasets: [{ data }] },
            options: {
              scales: {
                x: { title: { text: 'Monthly Price ($)' } },
                y: { title: { text: 'Feature Completeness (%)' } }
              }
            }
          };
        }

    example_usage: |
      $ sparc sim business:landscape

      ğŸ¯ Competitive Landscape

      Opening interactive chart at http://localhost:3001

      Competitors plotted:
      - Competitor A: ($99/mo, 85% features) - Leader
      - Competitor B: ($49/mo, 65% features) - Challenger
      - Competitor C: ($199/mo, 95% features) - Enterprise
      - Your position: ($79/mo, 80% features) - Projected

  - name: "pricing_comparison"
    command: "sparc sim business:pricing"
    description: "Interactive pricing tier comparison matrix"

    input:
      - "business/competitors/*.yaml"
      - "business/ideal/business-ideal.yaml#/optimal_business_model/pricing_strategy"

    output:
      type: "interactive_table"
      format: "html"

    features:
      - "Side-by-side tier comparison"
      - "Feature matrix with checkmarks"
      - "Price per feature analysis"
      - "Value metric comparison"
      - "Export to CSV/Markdown"

    implementation:
      library: "ag-grid"
      code_example: |
        // Generates comparison table from competitor pricing tiers
        const tiers = competitors.flatMap(c =>
          c.pricing.tiers.map(tier => ({
            competitor: c.name,
            tier: tier.name,
            price: tier.price,
            features: tier.features,
            limits: tier.limits
          }))
        );

  - name: "market_sizing"
    command: "sparc sim business:market"
    description: "TAM/SAM/SOM visualization"

    input:
      - "business/ideal/business-ideal.yaml#/competitor_synthesis/market_overview"

    output:
      type: "funnel_chart"
      format: "html"

    features:
      - "TAM/SAM/SOM funnel"
      - "Growth projections"
      - "Segment breakdown"
      - "Source citations"

  - name: "gtm_timeline"
    command: "sparc sim business:gtm"
    description: "Go-to-market timeline and milestones"

    input:
      - "business/ideal/business-ideal.yaml#/optimal_go_to_market"
      - "business/ideal/business-ideal.yaml#/roadmap"

    output:
      type: "gantt_chart"
      format: "html"

    features:
      - "Phase timeline visualization"
      - "Milestone markers"
      - "Resource allocation"
      - "Dependencies"
      - "Export to project management tools"

  - name: "unit_economics"
    command: "sparc sim business:unit-economics"
    description: "Unit economics calculator and projections"

    input:
      - "business/ideal/business-ideal.yaml#/optimal_business_model/target_unit_economics"

    output:
      type: "calculator"
      format: "html"

    features:
      - "Interactive CAC/LTV calculator"
      - "Payback period visualization"
      - "Sensitivity analysis"
      - "Scenario comparison"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SOFTWARE SIMULATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

software:

  - name: "feature_matrix"
    command: "sparc sim software:features"
    description: "Feature comparison across competitors"

    input:
      - "software/competitors/*.yaml"
      - "software/ideal/software-ideal.yaml"

    output:
      type: "interactive_table"
      format: "html"

    features:
      - "Feature-by-feature comparison"
      - "Maturity level indicators"
      - "Gap analysis highlighting"
      - "Filter by domain/priority"
      - "Export to spreadsheet"

  - name: "path_explorer"
    command: "sparc sim software:paths"
    description: "Interactive cyclomatic path explorer"
    status: "implemented"

    input:
      - "software/ideal/software-ideal.yaml#/feature_specifications"

    output:
      type: "interactive_flowchart"
      format: "html"

    features:
      - "Visual flow diagram for each feature"
      - "Click through decision points"
      - "See all possible paths"
      - "Path probability display"
      - "Test coverage indicator"
      - "Link to corresponding test"
      - "Export to Mermaid/PNG"
      - "Interactive path highlighting"

    implementation:
      library: "mermaid"
      status: "production_ready"

      # Complete implementation - ready to copy
      full_implementation: |
        // src/simulations/path-explorer.ts
        import express, { Express, Request, Response } from 'express';
        import { readFileSync, existsSync } from 'fs';
        import { parse as parseYaml } from 'yaml';
        import chalk from 'chalk';

        interface PathExplorerOptions {
          port: number;
          specDir: string;
          feature?: string;
        }

        interface DecisionPoint {
          id: string;
          name: string;
          condition: string;
          branches: Array<{ id: string; condition: string; result: string }>;
        }

        interface CyclomaticPath {
          id: string;
          name: string;
          probability?: string;
          steps: Array<{ decision_point: string; branch: string }>;
          expected_outcome: string;
        }

        interface FeatureSpec {
          name: string;
          description: string;
          decision_points: DecisionPoint[];
          cyclomatic_paths: CyclomaticPath[];
        }

        interface TestSpec {
          test_suites: Array<{
            feature: string;
            tests: Array<{ path_ref?: string; name: string }>;
          }>;
        }

        function loadSpec(specDir: string): any {
          const path = `${specDir}/software/ideal/software-ideal.yaml`;
          if (!existsSync(path)) {
            throw new Error(`Software spec not found: ${path}`);
          }
          return parseYaml(readFileSync(path, 'utf-8'));
        }

        function loadTests(specDir: string): TestSpec | null {
          const path = `${specDir}/tests/tests.yaml`;
          if (!existsSync(path)) return null;
          return parseYaml(readFileSync(path, 'utf-8'));
        }

        function getFeatures(spec: any): FeatureSpec[] {
          const features: FeatureSpec[] = [];

          // Handle nested domain structure
          if (spec.feature_specifications?.domains) {
            for (const domain of spec.feature_specifications.domains) {
              for (const feature of domain.features || []) {
                features.push(feature);
              }
            }
          }

          // Handle flat feature array
          if (Array.isArray(spec.feature_specifications)) {
            features.push(...spec.feature_specifications);
          }

          return features;
        }

        function generateMermaidFlowchart(feature: FeatureSpec): string {
          const lines: string[] = ['flowchart TD'];

          // Define nodes from decision points
          for (const dp of feature.decision_points || []) {
            // Decision points are diamonds
            const label = dp.condition.replace(/"/g, "'").substring(0, 50);
            lines.push(`  ${dp.id}{{"${label}"}}`);

            // Add branch result nodes
            for (const branch of dp.branches || []) {
              const resultId = `${dp.id}_${branch.id}`;
              const resultLabel = branch.result.replace(/"/g, "'").substring(0, 40);
              lines.push(`  ${resultId}["${resultLabel}"]`);
            }
          }

          // Add start and end nodes
          lines.push('  START([Start])');
          lines.push('  END([End])');

          // Connect decision points to branches
          for (const dp of feature.decision_points || []) {
            for (const branch of dp.branches || []) {
              const resultId = `${dp.id}_${branch.id}`;
              const condition = branch.condition.substring(0, 30);
              lines.push(`  ${dp.id} -->|"${condition}"| ${resultId}`);
            }
          }

          // Style decision points
          lines.push('  classDef decision fill:#ffd700,stroke:#333');
          lines.push('  classDef success fill:#90EE90,stroke:#333');
          lines.push('  classDef error fill:#FFB6C1,stroke:#333');

          for (const dp of feature.decision_points || []) {
            lines.push(`  class ${dp.id} decision`);
          }

          return lines.join('\n');
        }

        function calculateCoverage(
          paths: CyclomaticPath[],
          tests: TestSpec | null,
          featureName: string
        ): { total: number; covered: number; missing: string[] } {
          if (!tests) return { total: paths.length, covered: 0, missing: paths.map(p => p.id) };

          const featureTests = tests.test_suites?.find(s => s.feature === featureName);
          const testedPaths = new Set(
            featureTests?.tests?.map(t => t.path_ref).filter(Boolean) || []
          );

          const missing = paths.filter(p => !testedPaths.has(p.id)).map(p => p.id);

          return {
            total: paths.length,
            covered: paths.length - missing.length,
            missing
          };
        }

        function generateHTML(
          features: FeatureSpec[],
          selectedFeature: FeatureSpec | null,
          coverage: { total: number; covered: number; missing: string[] },
          mermaidCode: string
        ): string {
          const featureOptions = features
            .map(f => `<option value="${f.name}" ${selectedFeature?.name === f.name ? 'selected' : ''}>${f.name}</option>`)
            .join('');

          const pathsList = selectedFeature?.cyclomatic_paths?.map(p => {
            const isCovered = !coverage.missing.includes(p.id);
            const icon = isCovered ? 'âœ…' : 'âŒ';
            const prob = p.probability || 'N/A';
            return `<li class="${isCovered ? 'covered' : 'missing'}">
              <code>${p.id}</code> ${icon} ${p.name}
              <span class="probability">(${prob})</span>
            </li>`;
          }).join('') || '<li>No paths defined</li>';

          return `
          <!DOCTYPE html>
          <html>
          <head>
            <title>SPARC Path Explorer</title>
            <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
            <style>
              * { box-sizing: border-box; margin: 0; padding: 0; }
              body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                background: #1a1a2e;
                color: #eee;
                min-height: 100vh;
              }
              .header {
                background: #16213e;
                padding: 1rem 2rem;
                display: flex;
                align-items: center;
                gap: 2rem;
                border-bottom: 1px solid #0f3460;
              }
              .header h1 {
                font-size: 1.5rem;
                color: #e94560;
              }
              .header select {
                padding: 0.5rem 1rem;
                border-radius: 4px;
                background: #0f3460;
                color: #eee;
                border: 1px solid #e94560;
                font-size: 1rem;
              }
              .container {
                display: grid;
                grid-template-columns: 1fr 350px;
                height: calc(100vh - 60px);
              }
              .diagram {
                padding: 2rem;
                overflow: auto;
                background: #16213e;
              }
              .diagram .mermaid {
                background: white;
                padding: 2rem;
                border-radius: 8px;
              }
              .sidebar {
                background: #0f3460;
                padding: 1.5rem;
                overflow-y: auto;
              }
              .stats {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
                margin-bottom: 1.5rem;
              }
              .stat {
                background: #16213e;
                padding: 1rem;
                border-radius: 8px;
                text-align: center;
              }
              .stat-value {
                font-size: 2rem;
                font-weight: bold;
                color: #e94560;
              }
              .stat-label { font-size: 0.8rem; color: #888; }
              .coverage-bar {
                height: 8px;
                background: #333;
                border-radius: 4px;
                margin: 1rem 0;
                overflow: hidden;
              }
              .coverage-fill {
                height: 100%;
                background: linear-gradient(90deg, #e94560, #00ff88);
                border-radius: 4px;
              }
              .paths-list {
                list-style: none;
              }
              .paths-list li {
                padding: 0.75rem;
                margin: 0.5rem 0;
                background: #16213e;
                border-radius: 4px;
                border-left: 3px solid #333;
              }
              .paths-list li.covered { border-left-color: #00ff88; }
              .paths-list li.missing { border-left-color: #e94560; }
              .paths-list code {
                background: #0f3460;
                padding: 0.2rem 0.5rem;
                border-radius: 3px;
                font-size: 0.8rem;
              }
              .probability { color: #888; font-size: 0.8rem; }
              h3 { margin: 1rem 0; color: #e94560; }
              .export-btn {
                display: block;
                width: 100%;
                padding: 0.75rem;
                margin-top: 1rem;
                background: #e94560;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 1rem;
              }
              .export-btn:hover { background: #c73e54; }
            </style>
          </head>
          <body>
            <div class="header">
              <h1>ğŸ”€ SPARC Path Explorer</h1>
              <select onchange="window.location.href='?feature=' + this.value">
                <option value="">Select Feature...</option>
                ${featureOptions}
              </select>
            </div>

            <div class="container">
              <div class="diagram">
                <div class="mermaid">
                  ${mermaidCode || 'flowchart TD\n  A[Select a feature to view its paths]'}
                </div>
              </div>

              <div class="sidebar">
                <div class="stats">
                  <div class="stat">
                    <div class="stat-value">${selectedFeature?.decision_points?.length || 0}</div>
                    <div class="stat-label">Decision Points</div>
                  </div>
                  <div class="stat">
                    <div class="stat-value">${coverage.total}</div>
                    <div class="stat-label">Total Paths</div>
                  </div>
                </div>

                <h3>Test Coverage</h3>
                <div class="coverage-bar">
                  <div class="coverage-fill" style="width: ${coverage.total ? (coverage.covered / coverage.total * 100) : 0}%"></div>
                </div>
                <p>${coverage.covered}/${coverage.total} paths covered (${coverage.total ? Math.round(coverage.covered / coverage.total * 100) : 0}%)</p>

                <h3>Cyclomatic Paths</h3>
                <ul class="paths-list">
                  ${pathsList}
                </ul>

                <button class="export-btn" onclick="exportMermaid()">Export Mermaid</button>
              </div>
            </div>

            <script>
              mermaid.initialize({ startOnLoad: true, theme: 'default' });

              function exportMermaid() {
                const code = \`${mermaidCode.replace(/`/g, '\\`')}\`;
                const blob = new Blob([code], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'flowchart.mmd';
                a.click();
              }
            </script>
          </body>
          </html>
          `;
        }

        export async function startPathExplorer(options: PathExplorerOptions): Promise<Express> {
          const app = express();
          const spec = loadSpec(options.specDir);
          const tests = loadTests(options.specDir);
          const features = getFeatures(spec);

          console.log(chalk.cyan('\nğŸ”€ SPARC Path Explorer\n'));
          console.log(`Found ${chalk.green(features.length)} features with cyclomatic paths`);

          app.get('/', (req: Request, res: Response) => {
            const featureName = req.query.feature as string;
            const selectedFeature = featureName
              ? features.find(f => f.name === featureName) || null
              : null;

            const coverage = selectedFeature
              ? calculateCoverage(selectedFeature.cyclomatic_paths || [], tests, selectedFeature.name)
              : { total: 0, covered: 0, missing: [] };

            const mermaidCode = selectedFeature
              ? generateMermaidFlowchart(selectedFeature)
              : '';

            res.send(generateHTML(features, selectedFeature, coverage, mermaidCode));
          });

          // API endpoint for programmatic access
          app.get('/api/features', (req: Request, res: Response) => {
            res.json(features.map(f => ({
              name: f.name,
              description: f.description,
              decision_points: f.decision_points?.length || 0,
              paths: f.cyclomatic_paths?.length || 0
            })));
          });

          app.get('/api/features/:name', (req: Request, res: Response) => {
            const feature = features.find(f => f.name === req.params.name);
            if (!feature) {
              return res.status(404).json({ error: 'Feature not found' });
            }

            const coverage = calculateCoverage(
              feature.cyclomatic_paths || [],
              tests,
              feature.name
            );

            res.json({
              feature,
              coverage,
              mermaid: generateMermaidFlowchart(feature)
            });
          });

          app.listen(options.port, () => {
            console.log(`\nPath Explorer at ${chalk.green(`http://localhost:${options.port}`)}\n`);
            console.log('Features:');
            for (const f of features) {
              const pathCount = f.cyclomatic_paths?.length || 0;
              const dpCount = f.decision_points?.length || 0;
              console.log(`  ${f.name.padEnd(30)} ${dpCount} decisions, ${pathCount} paths`);
            }
            console.log('');
          });

          return app;
        }

    example_usage: |
      $ sparc sim software:paths

      ğŸ”€ SPARC Path Explorer

      Found 12 features with cyclomatic paths

      Path Explorer at http://localhost:3001

      Features:
        user_registration              9 decisions, 13 paths
        user_login                     7 decisions, 10 paths
        password_reset                 5 decisions, 8 paths
        notification_preferences       4 decisions, 6 paths

      # Open browser to interactive UI
      # Select feature from dropdown
      # View flowchart and path coverage
      # Export Mermaid code for documentation

  - name: "state_machine_viewer"
    command: "sparc sim software:states"
    description: "Interactive state machine visualization"

    input:
      - "software/ideal/software-ideal.yaml#/feature_specifications/*/state_machine"
      - "dsl/logic.yaml#/state_machines"

    output:
      type: "state_diagram"
      format: "html"

    features:
      - "Visual state diagram"
      - "Click transitions to see guards/actions"
      - "Simulate state transitions"
      - "See allowed actions per state"
      - "Export to XState visualizer"

    implementation:
      library: "@xstate/inspect"
      code_example: |
        // Converts SPARC state machine to XState machine
        import { createMachine } from 'xstate';

        function convertToXState(sparcMachine) {
          return createMachine({
            id: sparcMachine.name,
            initial: sparcMachine.initial_state,
            states: Object.fromEntries(
              sparcMachine.states.map(state => [
                state.name,
                {
                  on: Object.fromEntries(
                    state.transitions.map(t => [
                      t.event,
                      { target: t.to, guard: t.guard }
                    ])
                  )
                }
              ])
            )
          });
        }

  - name: "api_explorer"
    command: "sparc sim software:api"
    description: "Interactive API documentation"

    input:
      - "software/ideal/software-ideal.yaml#/feature_specifications/*/api"
      - "dsl/api.yaml"

    output:
      type: "swagger_ui"
      format: "html"

    features:
      - "OpenAPI/Swagger UI"
      - "Try endpoints (connected to mock server)"
      - "Request/response examples"
      - "Authentication testing"

    implementation:
      library: "swagger-ui-express"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TECHNICAL SIMULATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

technical:

  - name: "mock_server"
    command: "sparc sim api:mock"
    description: "Running mock API server from specification"
    status: "implemented"

    input:
      - "dsl/api.yaml"
      - "software/ideal/software-ideal.yaml#/feature_specifications/*/api"

    output:
      type: "server"
      port: 3000

    features:
      - "Full API mock from spec"
      - "Realistic response delays"
      - "Error simulation"
      - "Request logging"
      - "Stateful mode (remembers data)"
      - "Hot reload on spec changes"
      - "CORS enabled for local development"
      - "OpenAPI UI at /docs"

    implementation:
      library: "express"
      status: "production_ready"

      # Complete implementation - ready to copy
      full_implementation: |
        // src/simulations/mock-server.ts
        import express, { Express, Request, Response, NextFunction } from 'express';
        import cors from 'cors';
        import { readFileSync, watchFile } from 'fs';
        import { parse as parseYaml } from 'yaml';
        import chalk from 'chalk';

        interface MockOptions {
          port: number;
          stateful: boolean;
          delay?: number;
          errorRate?: number;
          specDir: string;
        }

        interface Endpoint {
          path: string;
          method: string;
          handler: string;
          auth: boolean;
          request?: { body?: Record<string, any>; params?: Record<string, any> };
          response?: { status: number; body?: any; schema?: any };
        }

        interface ApiSpec {
          version: string;
          base_path: string;
          endpoints: Endpoint[];
        }

        // In-memory store for stateful mode
        const store = new Map<string, Map<string, any>>();

        function loadApiSpec(specDir: string): ApiSpec {
          const content = readFileSync(`${specDir}/dsl/api.yaml`, 'utf-8');
          return parseYaml(content);
        }

        function generateMockData(schema: any): any {
          if (!schema) return null;

          if (schema.type === 'string') {
            if (schema.format === 'uuid') return crypto.randomUUID();
            if (schema.format === 'email') return 'user@example.com';
            if (schema.format === 'date-time') return new Date().toISOString();
            if (schema.enum) return schema.enum[0];
            return schema.example || 'mock_string';
          }

          if (schema.type === 'number' || schema.type === 'integer') {
            return schema.example || Math.floor(Math.random() * 100);
          }

          if (schema.type === 'boolean') {
            return schema.example ?? true;
          }

          if (schema.type === 'array') {
            const item = generateMockData(schema.items);
            return [item, item];
          }

          if (schema.type === 'object' || schema.properties) {
            const obj: Record<string, any> = {};
            for (const [key, propSchema] of Object.entries(schema.properties || {})) {
              obj[key] = generateMockData(propSchema);
            }
            return obj;
          }

          return null;
        }

        function getResourceName(path: string): string {
          // Extract resource name from path like /api/v1/users/:id -> users
          const parts = path.split('/').filter(p => p && !p.startsWith(':') && p !== 'api' && !p.match(/^v\d+$/));
          return parts[0] || 'default';
        }

        function handleStatefulRequest(
          method: string,
          path: string,
          params: Record<string, string>,
          body: any
        ): { status: number; data: any } {
          const resource = getResourceName(path);

          if (!store.has(resource)) {
            store.set(resource, new Map());
          }
          const resourceStore = store.get(resource)!;

          switch (method.toUpperCase()) {
            case 'GET': {
              if (params.id) {
                const item = resourceStore.get(params.id);
                if (!item) return { status: 404, data: { error: 'Not found' } };
                return { status: 200, data: item };
              }
              return { status: 200, data: Array.from(resourceStore.values()) };
            }

            case 'POST': {
              const id = crypto.randomUUID();
              const item = { id, ...body, created_at: new Date().toISOString() };
              resourceStore.set(id, item);
              return { status: 201, data: item };
            }

            case 'PUT':
            case 'PATCH': {
              if (!params.id) return { status: 400, data: { error: 'ID required' } };
              const existing = resourceStore.get(params.id);
              if (!existing) return { status: 404, data: { error: 'Not found' } };
              const updated = { ...existing, ...body, updated_at: new Date().toISOString() };
              resourceStore.set(params.id, updated);
              return { status: 200, data: updated };
            }

            case 'DELETE': {
              if (!params.id) return { status: 400, data: { error: 'ID required' } };
              if (!resourceStore.has(params.id)) return { status: 404, data: { error: 'Not found' } };
              resourceStore.delete(params.id);
              return { status: 204, data: null };
            }

            default:
              return { status: 405, data: { error: 'Method not allowed' } };
          }
        }

        function sleep(ms: number): Promise<void> {
          return new Promise(resolve => setTimeout(resolve, ms));
        }

        export async function startMockServer(options: MockOptions): Promise<Express> {
          const app = express();

          app.use(cors());
          app.use(express.json());

          // Request logging middleware
          app.use((req: Request, res: Response, next: NextFunction) => {
            const start = Date.now();
            res.on('finish', () => {
              const duration = Date.now() - start;
              const color = res.statusCode >= 400 ? chalk.red : chalk.green;
              console.log(
                color(`${req.method.padEnd(6)} ${req.path.padEnd(40)} ${res.statusCode} ${duration}ms`)
              );
            });
            next();
          });

          const apiSpec = loadApiSpec(options.specDir);

          // Register endpoints
          for (const endpoint of apiSpec.endpoints) {
            const method = endpoint.method.toLowerCase() as 'get' | 'post' | 'put' | 'patch' | 'delete';
            const fullPath = `${apiSpec.base_path || ''}${endpoint.path}`;

            (app as any)[method](fullPath, async (req: Request, res: Response) => {
              // Add configurable delay
              if (options.delay) {
                await sleep(options.delay);
              }

              // Simulate errors at configured rate
              if (options.errorRate && Math.random() < options.errorRate / 100) {
                return res.status(500).json({
                  error: 'Simulated server error',
                  message: 'This error was simulated by the mock server'
                });
              }

              // Handle stateful mode
              if (options.stateful) {
                const result = handleStatefulRequest(
                  endpoint.method,
                  endpoint.path,
                  req.params,
                  req.body
                );
                if (result.data === null) {
                  return res.status(result.status).send();
                }
                return res.status(result.status).json(result.data);
              }

              // Generate mock response from schema
              const responseBody = endpoint.response?.body
                || generateMockData(endpoint.response?.schema)
                || { success: true };

              res.status(endpoint.response?.status || 200).json(responseBody);
            });
          }

          // OpenAPI docs endpoint
          app.get('/docs', (req: Request, res: Response) => {
            res.send(`
              <!DOCTYPE html>
              <html>
              <head>
                <title>SPARC Mock API</title>
                <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css">
              </head>
              <body>
                <div id="swagger-ui"></div>
                <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"></script>
                <script>
                  SwaggerUIBundle({
                    url: '/openapi.json',
                    dom_id: '#swagger-ui'
                  });
                </script>
              </body>
              </html>
            `);
          });

          // Generate OpenAPI spec on the fly
          app.get('/openapi.json', (req: Request, res: Response) => {
            const openapi = {
              openapi: '3.0.0',
              info: { title: 'SPARC Mock API', version: apiSpec.version },
              paths: {} as Record<string, any>
            };

            for (const endpoint of apiSpec.endpoints) {
              const path = endpoint.path.replace(/:(\w+)/g, '{$1}');
              if (!openapi.paths[path]) openapi.paths[path] = {};
              openapi.paths[path][endpoint.method.toLowerCase()] = {
                summary: endpoint.handler,
                responses: {
                  [endpoint.response?.status || 200]: { description: 'Success' }
                }
              };
            }

            res.json(openapi);
          });

          // Health check
          app.get('/health', (req: Request, res: Response) => {
            res.json({ status: 'ok', stateful: options.stateful });
          });

          // Start server
          const server = app.listen(options.port, () => {
            console.log(chalk.cyan('\nğŸš€ SPARC Mock API Server\n'));
            console.log(`Server running at ${chalk.green(`http://localhost:${options.port}`)}`);
            console.log(`API docs at ${chalk.green(`http://localhost:${options.port}/docs`)}\n`);
            console.log(chalk.dim('Options:'));
            console.log(chalk.dim(`  Stateful: ${options.stateful}`));
            console.log(chalk.dim(`  Delay: ${options.delay || 0}ms`));
            console.log(chalk.dim(`  Error rate: ${options.errorRate || 0}%\n`));
            console.log(chalk.yellow('Endpoints:'));

            for (const endpoint of apiSpec.endpoints) {
              const fullPath = `${apiSpec.base_path || ''}${endpoint.path}`;
              console.log(`  ${endpoint.method.padEnd(6)} ${fullPath}`);
            }
            console.log('');
          });

          // Watch for spec changes (hot reload)
          watchFile(`${options.specDir}/dsl/api.yaml`, () => {
            console.log(chalk.yellow('\nğŸ“ API spec changed, restart server to apply changes\n'));
          });

          return app;
        }

    example_usage: |
      $ sparc sim api:mock

      ğŸš€ SPARC Mock API Server

      Server running at http://localhost:3000
      API docs at http://localhost:3000/docs

      Options:
        Stateful: false
        Delay: 0ms
        Error rate: 0%

      Endpoints:
        POST   /api/v1/auth/register
        POST   /api/v1/auth/login
        GET    /api/v1/notifications
        POST   /api/v1/notifications

      $ sparc sim api:mock --stateful --delay=200 --error-rate=5

      # Stateful mode: POST creates, GET retrieves, DELETE removes
      # Delay: 200ms added to all responses
      # Error rate: 5% of requests return 500

  - name: "ui_prototype"
    command: "sparc sim ui:prototype"
    description: "Interactive UI prototype from specification"

    input:
      - "dsl/ui.yaml"

    output:
      type: "storybook"
      port: 6006

    features:
      - "Storybook with all components"
      - "Screen previews"
      - "Interactive navigation"
      - "Mobile/tablet/desktop views"
      - "Dark mode toggle"

    implementation:
      library: "@storybook/react"
      code_example: |
        // Generates Storybook stories from ui.yaml
        function generateStories(uiSpec) {
          const stories = [];

          for (const component of uiSpec.components) {
            stories.push({
              title: `Components/${component.category}/${component.name}`,
              component: generateComponent(component),
              args: component.examples[0]?.props || {},
              argTypes: generateArgTypes(component.props)
            });
          }

          for (const screen of uiSpec.screens) {
            stories.push({
              title: `Screens/${screen.name}`,
              component: generateScreen(screen),
              parameters: {
                layout: 'fullscreen'
              }
            });
          }

          return stories;
        }

  - name: "database_diagram"
    command: "sparc sim data:diagram"
    description: "Entity relationship diagram"

    input:
      - "dsl/data.yaml"

    output:
      type: "erd"
      format: "html"

    features:
      - "Interactive ERD"
      - "Click entity for details"
      - "Relationship highlighting"
      - "Export to dbdiagram.io"
      - "Generate migration preview"

    implementation:
      library: "mermaid"
      code_example: |
        // Generates Mermaid ERD from data.yaml
        function generateERD(dataSpec) {
          let code = 'erDiagram\n';

          for (const entity of dataSpec.entities) {
            code += `  ${entity.name} {\n`;
            for (const field of entity.fields) {
              const pk = field.primary ? ' PK' : '';
              const fk = field.references ? ' FK' : '';
              code += `    ${field.type} ${field.name}${pk}${fk}\n`;
            }
            code += '  }\n';

            // Add relationships
            for (const relation of entity.relations || []) {
              const cardinality = {
                'one-to-one': '||--||',
                'one-to-many': '||--o{',
                'many-to-many': '}o--o{'
              }[relation.type];
              code += `  ${entity.name} ${cardinality} ${relation.target} : "${relation.name}"\n`;
            }
          }

          return code;
        }

  - name: "architecture_diagram"
    command: "sparc sim deploy:architecture"
    description: "System architecture visualization"

    input:
      - "dsl/deploy.yaml"
      - "architecture/platform-architecture.yaml"

    output:
      type: "diagram"
      format: "html"

    features:
      - "Service topology"
      - "Data flow arrows"
      - "Network boundaries"
      - "Database connections"
      - "Export to draw.io/Mermaid"

  - name: "cost_estimation"
    command: "sparc sim deploy:cost"
    description: "Infrastructure cost estimation"

    input:
      - "dsl/deploy.yaml"

    output:
      type: "calculator"
      format: "html"

    features:
      - "Monthly cost breakdown"
      - "Per-service costs"
      - "Scaling projections"
      - "Cost comparison (AWS vs GCP vs Azure)"
      - "Reserved instance savings"

    implementation:
      code_example: |
        // Cost calculation from deploy.yaml
        const PRICING = {
          aws: {
            compute: { 't3.micro': 8.35, 't3.small': 16.7, 't3.medium': 33.4 },
            rds: { 'db.t3.micro': 12.41, 'db.t3.small': 24.82 },
            elasticache: { 'cache.t3.micro': 12.41 },
            s3: { perGB: 0.023 },
            cloudfront: { perGB: 0.085 }
          }
        };

        function estimateCosts(deploySpec, cloud = 'aws') {
          const costs = {};
          const pricing = PRICING[cloud];

          for (const service of deploySpec.services) {
            const instanceType = service.resources?.instance_type || 't3.small';
            const replicas = service.replicas || 1;
            costs[service.name] = pricing.compute[instanceType] * replicas * 730; // hours/month
          }

          return costs;
        }

    example_usage: |
      $ sparc sim deploy:cost

      ğŸ’° Infrastructure Cost Estimation

      Environment: Production
      Cloud: AWS
      Region: us-east-1

      Monthly Costs:
      â”œâ”€â”€ Compute (EKS)        $450
      â”œâ”€â”€ Database (RDS)       $200
      â”œâ”€â”€ Cache (ElastiCache)  $100
      â”œâ”€â”€ Storage (S3)         $50
      â”œâ”€â”€ CDN (CloudFront)     $75
      â”œâ”€â”€ Monitoring           $50
      â””â”€â”€ Total               $925/month

      Scaling to 10x traffic: ~$3,500/month

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLATFORM SIMULATIONS (If platform architecture)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

platform:

  - name: "service_map"
    command: "sparc sim platform:services"
    description: "Service dependency visualization"

    input:
      - "architecture/platform-architecture.yaml#/bounded_contexts"

    output:
      type: "service_mesh"
      format: "html"

    features:
      - "Service boxes with health"
      - "Dependency arrows"
      - "API surface labels"
      - "Database connections"
      - "Click for service details"

  - name: "auth_flows"
    command: "sparc sim platform:auth"
    description: "Authentication flow sequence diagrams"

    input:
      - "architecture/platform-architecture.yaml#/unified_auth"
      - "dsl/auth.yaml"

    output:
      type: "sequence_diagram"
      format: "html"

    features:
      - "Login flow"
      - "OAuth flows (per provider)"
      - "Token refresh flow"
      - "Service-to-service auth"
      - "Export to Mermaid"

    implementation:
      library: "mermaid"
      code_example: |
        // Generate OTP login sequence diagram
        function generateOTPSequence() {
          return `
            sequenceDiagram
              participant U as User
              participant C as Client App
              participant A as Auth Service
              participant E as Email Provider
              participant D as Database

              U->>C: Enter email
              C->>A: POST /auth/otp/request
              A->>D: Check if user exists
              A->>A: Generate OTP code
              A->>D: Store hashed OTP
              A->>E: Send OTP email
              E-->>U: Email with code
              A-->>C: 200 OK (OTP sent)

              U->>C: Enter OTP code
              C->>A: POST /auth/otp/verify
              A->>D: Verify OTP hash
              A->>A: Generate JWT tokens
              A->>D: Store refresh token
              A-->>C: 200 OK (tokens)
              C->>C: Store tokens
          `;
        }

  - name: "event_flow"
    command: "sparc sim platform:events"
    description: "Event bus message flow visualization"

    input:
      - "architecture/platform-architecture.yaml#/cross_cutting/event_bus"

    output:
      type: "flow_diagram"
      format: "html"

    features:
      - "Publishers and subscribers"
      - "Event type catalog"
      - "Message flow animation"
      - "Dead letter queue visibility"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TESTING SIMULATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

testing:

  - name: "coverage_report"
    command: "sparc sim tests:coverage"
    description: "Path-to-test coverage mapping"

    input:
      - "software/ideal/software-ideal.yaml#/feature_specifications/*/paths"
      - "tests/tests.yaml"

    output:
      type: "coverage_report"
      format: "html"

    features:
      - "Path â†’ Test mapping"
      - "Missing test highlighting"
      - "Edge case coverage"
      - "Boundary coverage"
      - "Export to Markdown"

    implementation:
      code_example: |
        // src/simulations/testing/coverage.ts
        interface CoverageResult {
          feature: string;
          totalPaths: number;
          coveredPaths: number;
          missingPaths: string[];
          edgeCases: { total: number; covered: number };
          boundaries: { total: number; covered: number };
        }

        async function calculateCoverage(specDir: string): Promise<CoverageResult[]> {
          const softwareSpec = await loadYaml(`${specDir}/software/ideal/software-ideal.yaml`);
          const testsSpec = await loadYaml(`${specDir}/tests/tests.yaml`);

          const results: CoverageResult[] = [];

          for (const feature of softwareSpec.feature_specifications) {
            const paths = feature.cyclomatic_paths || [];
            const edges = feature.edge_cases || [];
            const boundaries = feature.boundary_conditions || [];

            const featureTests = testsSpec.test_suites
              .find(s => s.feature === feature.name)?.tests || [];

            const coveredPathIds = new Set(
              featureTests.map(t => t.path_ref).filter(Boolean)
            );

            results.push({
              feature: feature.name,
              totalPaths: paths.length,
              coveredPaths: paths.filter(p => coveredPathIds.has(p.id)).length,
              missingPaths: paths.filter(p => !coveredPathIds.has(p.id)).map(p => p.id),
              edgeCases: {
                total: edges.length,
                covered: edges.filter(e => coveredPathIds.has(e.id)).length
              },
              boundaries: {
                total: boundaries.length,
                covered: boundaries.filter(b => coveredPathIds.has(b.id)).length
              }
            });
          }

          return results;
        }

    example_usage: |
      $ sparc sim tests:coverage

      ğŸ“Š Cyclomatic Path Coverage Report

      Feature: User Registration
      â”œâ”€â”€ Paths: 13/13 covered (100%) âœ…
      â”œâ”€â”€ Edge Cases: 10/10 covered (100%) âœ…
      â””â”€â”€ Boundaries: 8/8 covered (100%) âœ…

      Feature: User Login
      â”œâ”€â”€ Paths: 8/10 covered (80%) âš ï¸
      â”‚   â””â”€â”€ Missing: PATH-009, PATH-010
      â”œâ”€â”€ Edge Cases: 5/6 covered (83%) âš ï¸
      â””â”€â”€ Boundaries: 4/4 covered (100%) âœ…

      Overall: 95% coverage

  - name: "test_matrix"
    command: "sparc sim tests:matrix"
    description: "Test case matrix visualization"

    input:
      - "tests/tests.yaml"

    output:
      type: "matrix"
      format: "html"

    features:
      - "Feature Ã— Test case matrix"
      - "Status indicators"
      - "Priority highlighting"
      - "Filter by status"

  - name: "mock_validation"
    command: "sparc sim tests:mocks"
    description: "Validate external service mocks"

    input:
      - "tests/mocks/*.yaml"

    output:
      type: "validation_report"
      format: "terminal"

    features:
      - "Mock completeness check"
      - "Scenario coverage"
      - "Response validation"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTERACTIVE MODE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interactive:

  command: "sparc interactive"
  description: "Full interactive exploration environment"

  features:
    - "Dashboard with all simulations"
    - "Cross-linked navigation"
    - "Live spec editing"
    - "Validation on save"
    - "Code generation triggers"

  port: 3001

  implementation:
    framework: "Next.js"
    ui_library: "shadcn/ui"
    code_example: |
      // Dashboard component structure
      export default function Dashboard() {
        return (
          <div className="grid grid-cols-4 gap-4 p-6">
            <SimulationCard
              title="Business"
              items={['Competitive Landscape', 'Pricing', 'Market Sizing']}
            />
            <SimulationCard
              title="Software"
              items={['Feature Matrix', 'Path Explorer', 'State Machines']}
            />
            <SimulationCard
              title="Technical"
              items={['Mock Server', 'UI Prototype', 'Database Diagram']}
            />
            <SimulationCard
              title="Testing"
              items={['Coverage Report', 'Test Matrix']}
            />
          </div>
        );
      }

  sections:
    - name: "Business"
      simulations:
        - "competitive_landscape"
        - "pricing_comparison"
        - "market_sizing"
        - "gtm_timeline"

    - name: "Software"
      simulations:
        - "feature_matrix"
        - "path_explorer"
        - "state_machine_viewer"
        - "api_explorer"

    - name: "Technical"
      simulations:
        - "mock_server"
        - "ui_prototype"
        - "database_diagram"
        - "architecture_diagram"
        - "cost_estimation"

    - name: "Platform"
      condition: "architecture.type == 'platform'"
      simulations:
        - "service_map"
        - "auth_flows"
        - "event_flow"

    - name: "Testing"
      simulations:
        - "coverage_report"
        - "test_matrix"
        - "mock_validation"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VALIDATION COMMAND
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

validate:

  command: "sparc validate"
  description: "Validate all specifications for completeness"

  implementation:
    code_example: |
      // src/validation/validator.ts
      import Ajv from 'ajv';
      import { glob } from 'glob';
      import { loadYaml } from '../utils';

      export class Validator {
        private ajv: Ajv;

        constructor() {
          this.ajv = new Ajv({ allErrors: true, strict: false });
          this.loadSchemas();
        }

        private async loadSchemas() {
          const schemaFiles = await glob('schemas/json-schemas/*.schema.json');
          for (const file of schemaFiles) {
            const schema = await loadYaml(file);
            this.ajv.addSchema(schema);
          }
        }

        async validate(fix: boolean = false): Promise<ValidationResult> {
          const results: CheckResult[] = [];

          // 1. Schema validation
          results.push(await this.validateSchemas());

          // 2. Cross-reference validation
          results.push(await this.validateCrossReferences());

          // 3. Path completeness
          results.push(await this.validatePathCompleteness());

          // 4. Test coverage
          results.push(await this.validateTestCoverage());

          // 5. DSL consistency
          results.push(await this.validateDSLConsistency());

          return {
            success: results.every(r => r.passed),
            results
          };
        }

        private async validateSchemas(): Promise<CheckResult> {
          const files = await glob('**/*.yaml', { ignore: 'node_modules/**' });
          const errors: string[] = [];

          for (const file of files) {
            const content = await loadYaml(file);
            if (content.$schema) {
              const validate = this.ajv.getSchema(content.$schema);
              if (validate && !validate(content)) {
                errors.push(`${file}: ${this.ajv.errorsText(validate.errors)}`);
              }
            }
          }

          return {
            name: 'Schema validation',
            passed: errors.length === 0,
            errors
          };
        }
      }

  checks:
    - name: "Schema validation"
      description: "All YAML files match their schemas"

    - name: "Cross-reference validation"
      description: "All references between files are valid"

    - name: "Path completeness"
      description: "All features have complete cyclomatic paths"

    - name: "Test coverage"
      description: "All paths have corresponding tests"

    - name: "DSL consistency"
      description: "DSL files are internally consistent"

  output:
    format: "terminal"

    example: |
      $ sparc validate

      âœ… Schema validation passed
      âœ… Cross-reference validation passed
      âœ… Path completeness passed (147 paths across 12 features)
      âš ï¸ Test coverage: 142/147 paths covered (97%)
         Missing: login/PATH-009, login/PATH-010, payment/PATH-015
      âœ… DSL consistency passed

      Overall: 4/5 checks passed

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CODE GENERATION COMMAND
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

generate:

  command: "sparc generate <target>"
  description: "Generate code from DSL specifications"

  targets:
    - name: "all"
      description: "Generate all targets"

    - name: "api"
      description: "Generate API routes and OpenAPI spec"
      input: "dsl/api.yaml"
      outputs:
        - "src/routes/**/*.ts"
        - "openapi.yaml"

    - name: "db"
      description: "Generate database schema and migrations"
      input: "dsl/data.yaml"
      outputs:
        - "src/db/schema.ts"
        - "migrations/*.sql"

    - name: "ui"
      description: "Generate UI components"
      input: "dsl/ui.yaml"
      outputs:
        - "src/components/**/*.tsx"

    - name: "tests"
      description: "Generate test scaffolding"
      input: "tests/tests.yaml"
      outputs:
        - "tests/**/*.test.ts"

  implementation:
    code_example: |
      // src/generation/generator.ts
      import Handlebars from 'handlebars';
      import { loadYaml, writeFile } from '../utils';

      export class Generator {
        private templates: Map<string, HandlebarsTemplateDelegate>;

        constructor() {
          this.templates = new Map();
          this.registerHelpers();
        }

        private registerHelpers() {
          Handlebars.registerHelper('pascal', (str) =>
            str.replace(/[-_](\w)/g, (_, c) => c.toUpperCase())
               .replace(/^\w/, c => c.toUpperCase())
          );

          Handlebars.registerHelper('snake', (str) =>
            str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '')
          );

          Handlebars.registerHelper('kebab', (str) =>
            str.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '')
          );
        }

        async generate(target: string, outputDir?: string) {
          const config = await loadYaml('package.yaml');
          const interpreter = config.interpreters[target];

          for (const targetConfig of interpreter) {
            const template = await this.loadTemplate(targetConfig.template);
            const input = await loadYaml(config.contents.dsl[target].file);

            const output = template(input);
            await writeFile(targetConfig.output, output);
          }
        }
      }

  example_usage: |
    $ sparc generate api

    ğŸ”¨ Generating API routes...

    Generated:
    â”œâ”€â”€ src/routes/auth.ts (12 endpoints)
    â”œâ”€â”€ src/routes/notifications.ts (8 endpoints)
    â”œâ”€â”€ src/routes/users.ts (6 endpoints)
    â””â”€â”€ openapi.yaml

    $ sparc generate all

    ğŸ”¨ Generating all targets...

    Generated:
    â”œâ”€â”€ Database schema (5 tables)
    â”œâ”€â”€ API routes (26 endpoints)
    â”œâ”€â”€ UI components (15 components)
    â”œâ”€â”€ Test scaffolding (45 test cases)
    â””â”€â”€ OpenAPI spec
